name: Preview Deployment

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - master

concurrency:
  group: preview-${{ github.event.pull_request.number }}
  cancel-in-progress: true

env:
  CHANGE_ID: ${{ github.event.pull_request.number }}
  SHORT_SHA: ${{ github.sha }}
  REGISTRY: hmctspublic.azurecr.io

jobs:
  detect-affected:
    name: Detect Affected Apps
    runs-on: ubuntu-latest
    outputs:
      affected-apps: ${{ steps.detect.outputs.affected-apps }}
      helm-apps: ${{ steps.detect.outputs.helm-apps }}
      has-changes: ${{ steps.detect.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Enable Corepack
        run: corepack enable

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'
          cache: 'yarn'
          cache-dependency-path: '**/yarn.lock'

      - name: Install dependencies
        run: yarn install --immutable

      - name: Detect affected apps
        id: detect
        run: .github/scripts/detect-affected-apps.sh

  build-and-publish:
    name: Build & Publish ${{ matrix.app }}
    runs-on: ubuntu-latest
    needs: detect-affected
    if: needs.detect-affected.outputs.has-changes == 'true'
    strategy:
      matrix:
        app: ${{ fromJson(needs.detect-affected.outputs.affected-apps) }}
    permissions:
      contents: read
      id-token: write
    outputs:
      timestamp: ${{ steps.metadata.outputs.timestamp }}
      short-sha: ${{ steps.metadata.outputs.short-sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Generate build metadata
        id: metadata
        run: .github/scripts/generate-build-metadata.sh "${{ env.CHANGE_ID }}" "${{ github.sha }}" "${{ matrix.app }}"

      - name: 'Build and push image'
        uses: azure/docker-login@v2
        with:
          login-server: ${{ secrets.REGISTRY_LOGIN_SERVER }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Build and push Docker image
        run: |
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.REGISTRY_PREFIX }}"
          FULL_TAG="${IMAGE_NAME}:${{ env.IMAGE_TAG }}"
          STATIC_TAG="${IMAGE_NAME}:pr-${{ env.CHANGE_ID }}"

          echo "Building image: ${FULL_TAG}"

          docker build \
            --tag "${FULL_TAG}" \
            --tag "${STATIC_TAG}" \
            --file apps/${{ matrix.app }}/Dockerfile \
            .

          echo "Pushing timestamped tag: ${FULL_TAG}"
          docker push "${FULL_TAG}"

          echo "Pushing static tag: ${STATIC_TAG}"
          docker push "${STATIC_TAG}"

          echo "Successfully pushed both tags"

  deploy-preview:
    name: Deploy to Preview
    runs-on: ubuntu-latest
    needs: [detect-affected, build-and-publish]
    if: needs.detect-affected.outputs.has-changes == 'true'
    environment:
      name: preview
    outputs:
      urls: ${{ steps.preview-urls.outputs.urls }}
    permissions:
      contents: read
      id-token: write
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set environment variables
        run: |
          # Read metadata from root Helm chart
          CHART_PATH="helm/expressjs-monorepo-template/Chart.yaml"

          TEAM_NAME=$(grep -A 1 'annotations:' "$CHART_PATH" | grep 'team:' | awk '{print $2}' | tr -d '"')
          APPLICATION_NAME=$(grep '^name:' "$CHART_PATH" | awk '{print $2}' | tr -d '"')
          GIT_REPO=$(git config --get remote.origin.url | sed 's/git@github.com:/https:\/\/github.com\//' | sed 's/\.git$//')

          echo "TEAM_NAME=${TEAM_NAME}" >> $GITHUB_ENV
          echo "APPLICATION_NAME=${APPLICATION_NAME}" >> $GITHUB_ENV
          echo "GIT_REPO=${GIT_REPO}" >> $GITHUB_ENV
          echo "TIMESTAMP=${{ needs.build-and-publish.outputs.timestamp }}" >> $GITHUB_ENV
          echo "SHORT_SHA=${{ needs.build-and-publish.outputs.short-sha }}" >> $GITHUB_ENV

          # Set dynamic image variables and release name
          .github/scripts/set-image-variables.sh \
            '${{ needs.detect-affected.outputs.affected-apps }}' \
            '${{ needs.detect-affected.outputs.helm-apps }}' \
            '${{ env.CHANGE_ID }}' \
            '${{ needs.build-and-publish.outputs.short-sha }}' \
            '${{ needs.build-and-publish.outputs.timestamp }}' \
            "${APPLICATION_NAME}"

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_CFT_PREVIEW }}

      # TODO change the preview resource group and name
      - name: Get AKS credentials
        run: |
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_CFT_PREVIEW }}
          az aks get-credentials \
            --admin \
            --resource-group cft-preview-01-rg \
            --name cft-preview-01-aks \
            --overwrite-existing

      - name: Install and configure kubelogin
        run: |
          # Get latest kubelogin version
          KUBELOGIN_VERSION=$(curl -s https://api.github.com/repos/Azure/kubelogin/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

          # Install kubelogin
          curl -LO "https://github.com/Azure/kubelogin/releases/download/${KUBELOGIN_VERSION}/kubelogin-linux-amd64.zip"
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf kubelogin-linux-amd64.zip bin/

          # Convert kubeconfig to use kubelogin
          kubelogin convert-kubeconfig -l azurecli

      - name: Install Helm
        uses: azure/setup-helm@v4
        with:
          version: '3.13.0'

      - name: Login to Helm registry
        run: |
          echo ${{ secrets.REGISTRY_PASSWORD }} | helm registry login hmctspublic.azurecr.io \
            --username ${{ secrets.REGISTRY_USERNAME }} \
            --password-stdin

      - name: Deploy preview environment
        run: .github/scripts/deploy-preview.sh ${{ env.CHANGE_ID }}

      - name: Get preview URLs from ingress
        id: preview-urls
        run: |
          # Get URLs and base64 encode to avoid special character issues in GitHub Actions
          URLS_JSON=$(.github/scripts/get-preview-urls.sh "${{ env.TEAM_NAME }}" "${{ env.RELEASE_NAME }}")
          URLS_B64=$(echo -n "${URLS_JSON}" | base64 -w 0)
          echo "urls=${URLS_B64}" >> "$GITHUB_OUTPUT"

      - name: Add PR labels for cleanup
        uses: actions/github-script@v8
        with:
          script: |
            const teamName = '${{ env.TEAM_NAME }}';
            const applicationName = '${{ env.APPLICATION_NAME }}';
            const labels = [
              `ns:${teamName}`,
              `prd:${teamName}`,
              `rel:${applicationName}-pr-${{ env.CHANGE_ID }}`
            ];

            for (const label of labels) {
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: [label]
                });
              } catch (error) {
                console.log(`Failed to add label ${label}: ${error.message}`);
              }
            }

      - name: Comment preview URLs
        uses: actions/github-script@v8
        with:
          script: |
            // Decode base64-encoded URLs
            const urlsB64 = '${{ steps.preview-urls.outputs.urls }}';
            const urlsJson = Buffer.from(urlsB64, 'base64').toString('utf-8');
            const urls = JSON.parse(urlsJson || '{}');

            // Build URL list dynamically from ingress resources
            const urlList = Object.entries(urls)
              .map(([app, url]) => {
                const appName = app.split('_').map(word =>
                  word.charAt(0).toUpperCase() + word.slice(1)
                ).join(' ');
                return `- **${appName}**: ${url}`;
              })
              .join('\n');

            const body = [
              '## Preview Deployment Successful ðŸš€',
              '',
              'Your preview environment is ready:',
              '',
              urlList || '_(No ingress URLs found)_',
              '',
              'The environment will be automatically cleaned up when this PR is closed.'
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: [detect-affected, deploy-preview]
    if: needs.detect-affected.outputs.has-changes == 'true'
    timeout-minutes: 15
    permissions:
      contents: read
      checks: write
      pull-requests: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'

      - name: Enable Corepack
        run: corepack enable

      - name: Install dependencies
        run: yarn install --immutable

      - name: Install Playwright browsers
        run: yarn workspace e2e-tests playwright install --with-deps chromium

      - name: Set environment variables
        run: |
          # Read metadata from root Helm chart
          CHART_PATH="helm/expressjs-monorepo-template/Chart.yaml"

          TEAM_NAME=$(grep -A 1 'annotations:' "$CHART_PATH" | grep 'team:' | awk '{print $2}' | tr -d '"')
          APPLICATION_NAME=$(grep '^name:' "$CHART_PATH" | awk '{print $2}' | tr -d '"')

          echo "TEAM_NAME=${TEAM_NAME}" >> $GITHUB_ENV
          echo "APPLICATION_NAME=${APPLICATION_NAME}" >> $GITHUB_ENV
          echo "RELEASE_NAME=${APPLICATION_NAME}-pr-${{ env.CHANGE_ID }}" >> $GITHUB_ENV

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS_CFT_PREVIEW }}

      - name: Get AKS credentials
        run: |
          az account set --subscription ${{ secrets.AZURE_SUBSCRIPTION_CFT_PREVIEW }}
          az aks get-credentials \
            --admin \
            --resource-group cft-preview-01-rg \
            --name cft-preview-01-aks \
            --overwrite-existing

      - name: Install and configure kubelogin
        run: |
          # Get latest kubelogin version
          KUBELOGIN_VERSION=$(curl -s https://api.github.com/repos/Azure/kubelogin/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')

          # Install kubelogin
          curl -LO "https://github.com/Azure/kubelogin/releases/download/${KUBELOGIN_VERSION}/kubelogin-linux-amd64.zip"
          unzip kubelogin-linux-amd64.zip
          sudo mv bin/linux_amd64/kubelogin /usr/local/bin/
          rm -rf kubelogin-linux-amd64.zip bin/

          # Convert kubeconfig to use kubelogin
          kubelogin convert-kubeconfig -l azurecli

      - name: Setup port-forwards to preview environment
        run: |
          .github/scripts/setup-port-forwards.sh "${{ env.TEAM_NAME }}" "${{ env.RELEASE_NAME }}"

          # Set environment variables for Playwright to use localhost URLs
          echo "EXPRESSJS_MONOREPO_TEMPLATE_WEB_URL=http://localhost:3000" >> $GITHUB_ENV
          echo "EXPRESSJS_MONOREPO_TEMPLATE_API_URL=http://localhost:3001" >> $GITHUB_ENV
          echo "EXPRESSJS_MONOREPO_TEMPLATE_POSTGRES_URL=http://localhost:5555" >> $GITHUB_ENV

          echo "Preview environment accessible via port-forwards:"
          echo "  Web: http://localhost:3000"
          echo "  API: http://localhost:3001"

      - name: Run E2E tests against preview
        id: e2e-tests
        run: |
          # Capture all output including server logs
          set -o pipefail
          yarn workspace e2e-tests run test:e2e 2>&1 | tee e2e-server-logs.txt

      # Publish test results to PR checks
      - name: Test Report
        id: test-report
        uses: dorny/test-reporter@v2
        if: always()
        with:
          name: E2E Test Results (Preview)
          path: e2e-tests/junit-results.xml
          reporter: java-junit
          fail-on-error: false

      # Upload artifacts on failure for debugging
      - name: Upload Playwright test results
        uses: actions/upload-artifact@v5
        if: always() && steps.e2e-tests.outcome == 'failure'
        with:
          name: playwright-test-results-preview
          path: |
            e2e-tests/test-results/
            e2e-tests/playwright-report/
          retention-days: 7

      # Upload application logs on failure for debugging
      - name: Upload application logs
        uses: actions/upload-artifact@v5
        if: always() && steps.e2e-tests.outcome == 'failure'
        with:
          name: application-logs-preview
          path: e2e-server-logs.txt
          retention-days: 7

      # Publish test results as a PR comment
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2
        if: always() && github.event_name == 'pull_request'
        with:
          files: e2e-tests/junit-results.xml
          check_name: E2E Test Results (Preview)
          comment_title: ðŸŽ­ Playwright E2E Test Results (Preview Environment)
          fail_on: nothing

      # Cleanup port-forwards
      - name: Cleanup port-forwards
        if: always()
        run: .github/scripts/cleanup-port-forwards.sh "${{ env.RELEASE_NAME }}"
